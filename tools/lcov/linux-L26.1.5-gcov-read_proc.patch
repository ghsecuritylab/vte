diff -Naur linux-2.6.7-mxc1.5-gcov-2.6.5/drivers/gcov/gcov-proc.c linux-2.6.7-mxc1.5_COV/drivers/gcov/gcov-proc.c
--- linux-2.6.7-mxc1.5-gcov-2.6.5/drivers/gcov/gcov-proc.c	2004-11-04 11:13:09.000000000 +0100
+++ linux-2.6.7-mxc1.5_COV/drivers/gcov/gcov-proc.c	2004-11-02 15:38:57.000000000 +0100
@@ -44,6 +44,7 @@
 #include <asm/uaccess.h>
 #include <linux/gcov.h>
 
+#define CGDDBG() printk("%d: %s()\n", __LINE__, __FUNCTION__)
 
 MODULE_LICENSE("GPL");
 
@@ -876,36 +877,66 @@
 	struct proc_dir_entry *dir_entry;
 	ssize_t rc;
 
+	CGDDBG();
 	down(&gcov_lock);
+	CGDDBG();
 	dir_entry = PDE(file->f_dentry->d_inode);
 	rc = 0;
+	CGDDBG();
 	if (dir_entry == proc_vmlinux) {
 		/* Are we in a sequential read? */
+		CGDDBG();
 		if (cached_node && (*pos >= cached_node->offset))
+		{
+			CGDDBG();
 			node = cached_node;
+		}
 		else
+		{
+			CGDDBG();
 			node = leaf_nodes;
+		}
 		/* Find node corresponding to offset */
 		while (node && node->next && (*pos >= node->next->offset))
+		{
+			CGDDBG();
 			node = node->next;
+		}
 		cached_node = node;
+		CGDDBG();
 		if (node) {
+			CGDDBG();
 			if (*pos - node->offset < node->header_size)
+			{
+				CGDDBG();
 				rc = store_vmlinux_header(node, buf, count,
 							  *pos - node->offset);
+			}
 			else
+			{
+				CGDDBG();
 				rc = store_da_file(node, buf, count,
 						   *pos - node->offset -
 							node->header_size);
+			}
 		}
 	} else {
+		CGDDBG();
 		node = (struct gcov_ftree_node *) dir_entry->data;
 		if (node)
+		{
+			CGDDBG();
 			rc = store_da_file(node, buf, count, *pos);
+		}
 	}
 	if (rc > 0)
+	{
+		CGDDBG();
 		*pos += rc;
+	}
+	CGDDBG();	
 	up(&gcov_lock);
+	CGDDBG();
 	return rc;
 }
 
